{
  "_args": [
    [
      {
        "raw": "ffi-generate@>= 0",
        "scope": null,
        "escapedName": "ffi-generate",
        "name": "ffi-generate",
        "rawSpec": ">= 0",
        "spec": ">=0.0.0",
        "type": "range"
      },
      "/Users/jpchen/jstorch/torch.js"
    ]
  ],
  "_from": "ffi-generate@>=0.0.0",
  "_id": "ffi-generate@0.0.8",
  "_inCache": true,
  "_location": "/ffi-generate",
  "_npmUser": {
    "name": "tjfontaine",
    "email": "tjfontaine@gmail.com"
  },
  "_npmVersion": "1.3.11",
  "_phantomChildren": {},
  "_requested": {
    "raw": "ffi-generate@>= 0",
    "scope": null,
    "escapedName": "ffi-generate",
    "name": "ffi-generate",
    "rawSpec": ">= 0",
    "spec": ">=0.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/ffi-generate/-/ffi-generate-0.0.8.tgz",
  "_shasum": "d2ee7013bdb948454940897b5cd072001d51daf9",
  "_shrinkwrap": null,
  "_spec": "ffi-generate@>= 0",
  "_where": "/Users/jpchen/jstorch/torch.js",
  "author": {
    "name": "Timothy J Fontaine",
    "email": "tjfontaine@gmail.com"
  },
  "bin": {
    "ffi-generate": "bin/ffi-generate.js"
  },
  "dependencies": {
    "hogan.js": ">= 2.0.0",
    "js-beautify": "",
    "libclang": ">= 0.0.10",
    "optimist": ""
  },
  "description": "Generate FFI Bindings from header file",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "shasum": "d2ee7013bdb948454940897b5cd072001d51daf9",
    "tarball": "https://registry.npmjs.org/ffi-generate/-/ffi-generate-0.0.8.tgz"
  },
  "keywords": [
    "libclang",
    "ffi",
    "bindings"
  ],
  "license": "MIT",
  "main": "lib/generateffi.js",
  "maintainers": [
    {
      "name": "tjfontaine",
      "email": "tjfontaine@gmail.com"
    }
  ],
  "name": "ffi-generate",
  "optionalDependencies": {},
  "readme": "`npm install -g ffi-generate`\n\nGenerate FFI Bindings\n---------------------\n`ffi-generate -f /path/to/myLibrary/header.h -l libmyLibrary`\n\nWill parse the given filename and print to standard out the resulting javascript\nsuitable for use as a module.\n\n * f -- required -- The header file you wish to parse\n * l -- required -- The library FFI will use to dlopen\n * m -- optional -- The module name underwhich functions will be stored (uses library name otherwise)\n * p -- optional -- Only include functions whose name starts with the provided prefix\n  - you can specify multiple `-p` on the command line to get multiple prefixes\n * x -- optional -- Restrict to only functions declared in the given header file\n * s -- optional -- Use StrictType type wrapper (experimental)\n * L -- optional -- If libclang.{so,dylib} is in a non-standard path use this\nwhich will rerun the process with `[DY]LD_LIBRARY_PATH` set\n\nIt may be necessary to pass additional flags to libclang so it can better parse\nthe header (i.e. include paths). To pass options directly to libclang use `--`\nso ffi-generate-node knows to stop parsing arguments, the rest will be passed\nto libclang without modification.\n\n`ffi-generate -f /usr/include/ImageMagick/wand/MagickWand.h -l libMagickWand -m wand -p Magick -- $(Magick-config --cflags)`\n\nGenerate FFI Bindings Programatically\n-------------------------------------\n```javascript\nvar exec = require('child_process').exec;\nvar path = require('path');\nvar fs = require('fs');\nvar jsb = require('beautifyjs');\nvar generate = require('lib/generateffi').generate;\n\nexec('llvm-config --includedir', function (fail, out, err) {\n  var includedir = out.replace(/\\s+$/, '');\n  var result = exports.generate({\n    filename: path.join(includedir, 'clang-c', 'Index.h'),\n    library: 'libclang',\n    prefix: 'clang_', \n    includes: [includedir],\n  });\n\n  if (result.unmapped.length > 0) {\n    console.log('----- UNMAPPED FUNCTIONS -----');\n    console.log(result.unmapped);\n    console.log('----- UNMAPPED FUNCTIONS -----');\n  }\n\n  fs.writeFileSync(path.join(__dirname, 'dynamic_clang.js'), jsb.js_beautify(result.serialized));\n  var dynamic_clang = require(path.join(__dirname, 'dynamic_clang'));\n  var ver = dynamic_clang.libclang.clang_getClangVersion();\n  console.log(dynamic_clang.libclang.clang_getCString(ver));\n  dynamic_clang.libclang.clang_disposeString(ver)\n});\n````\nInput to the generate method\n\n * opts.filename -- required -- the full path to the header source file to parse \n * opts.library -- required -- the library ffi should use to dlopen\n * opts.module -- optional -- the name of the module that will be exported (otherwise uses library name)\n * opts.prefix -- optional --  restrict imported functions to a given prefix\n * opts.includes -- optional -- a set of directory paths to aid type expansion\n * opts.compiler_args -- optional -- a set of clang command line options passed to the parser\n * opts.single_file -- optional -- restricts functions to only those defined in the header file\n   - this does not restrict dependent types\n\nThe result from generate is an object that has two properties\n\n * serialized - a string representation of the bindings suitable for writing to file\n * unmapped - a set of functions that failed to map -- most likely from failure to\nmap a type to ffi type.\n  - each element is an object with following properties\n   * position - -1 means the return type, otherwise the argument\n   * arg - name of the type that failed to map\n   * name - the name of the function that failed\n   * decl - the signature of the function that failed\n\n",
  "readmeFilename": "README.md",
  "version": "0.0.8"
}
